import type { Question } from "../../types"

const doublyLinkedListQuestion: Question = {
  category: "data-structures",
  level: "Medium",
  name: "Doubly Linked List",
  solution:
    "class DoublyLinkedListNode<T> {\n  public value: T\n  public next: DoublyLinkedListNode<T> | null\n  public prev: DoublyLinkedListNode<T> | null\n\n  constructor(value: T) {\n    this.value = value\n    this.next = null\n    this.prev = null\n  }\n}\n\nexport class DoublyLinkedList<T> {\n  public head: DoublyLinkedListNode<T> | null\n  public tail: DoublyLinkedListNode<T> | null\n  private length: number\n\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n\n  public get size(): number {\n    return this.length\n  }\n\n  public isEmpty(): boolean {\n    return this.length === 0\n  }\n\n  public addTail(value: T): void {\n    const newNode = new DoublyLinkedListNode(value)\n    if (this.isEmpty()) {\n      this.head = newNode\n      this.tail = newNode\n    } else {\n      this.tail!.next = newNode\n      newNode.prev = this.tail\n      this.tail = newNode\n    }\n    this.length++\n  }\n\n  public addHead(value: T): void {\n    const newNode = new DoublyLinkedListNode(value)\n    if (this.isEmpty()) {\n      this.head = newNode\n      this.tail = newNode\n    } else {\n      this.head!.prev = newNode\n      newNode.next = this.head\n      this.head = newNode\n    }\n    this.length++\n  }\n\n  public removeTail(): T | null {\n    if (!this.tail) {\n      return null\n    }\n    const value = this.tail.value\n    if (this.head === this.tail) {\n      this.head = null\n      this.tail = null\n    } else {\n      this.tail = this.tail.prev\n      this.tail!.next = null\n    }\n    this.length--\n    return value\n  }\n\n  public removeHead(): T | null {\n    if (!this.head) {\n      return null\n    }\n    const value = this.head.value\n    if (this.head === this.tail) {\n      this.head = null\n      this.tail = null\n    } else {\n      this.head = this.head.next\n      this.head!.prev = null\n    }\n    this.length--\n    return value\n  }\n\n  public find(value: T): DoublyLinkedListNode<T> | null {\n    let current = this.head\n    while (current) {\n      if (current.value === value) {\n        return current\n      }\n      current = current.next\n    }\n    return null\n  }\n\n  public delete(value: T): boolean {\n    const nodeToDelete = this.find(value)\n    if (!nodeToDelete) {\n      return false\n    }\n\n    if (nodeToDelete === this.head) {\n      this.removeHead()\n    } else if (nodeToDelete === this.tail) {\n      this.removeTail()\n    } else {\n      nodeToDelete.prev!.next = nodeToDelete.next\n      nodeToDelete.next!.prev = nodeToDelete.prev\n      this.length--\n    }\n    return true\n  }\n\n  public toArray(): T[] {\n    const result: T[] = [];\n    let current = this.head;\n    while (current) {\n      result.push(current.value);\n      current = current.next;\n    }\n    return result;\n  }\n}",
  synopsis:
    "Doubly Linked List\n\nWhat is a Doubly Linked List?\n\nA doubly linked list is a linear data structure that consists of a sequence of nodes, where each node contains a value and two pointers: `next` and `prev`. The `next` pointer points to the next node in the sequence, and the `prev` pointer points to the previous node. This bidirectional linkage allows for traversal in both forward and backward directions.\n\nHow it Works:\n\n- Each node in a doubly linked list is an object with three properties: `value`, `next`, and `prev`.\n- The list maintains a `head` pointer to the first node and a `tail` pointer to the last node.\n- When a new node is added, the `next` and `prev` pointers of the surrounding nodes are updated to maintain the integrity of the list.\n- Traversal can start from the `head` and move forward using the `next` pointer, or start from the `tail` and move backward using the `prev` pointer.\n\nHow to Implement it:\n\n1.  **Node Class:** Create a `DoublyLinkedListNode` class with properties for `value`, `next`, and `prev`.\n2.  **DoublyLinkedList Class:** Create a `DoublyLinkedList` class with properties for `head`, `tail`, and `length`.\n3.  **`addTail` Method:**\n    - Create a new node.\n    - If the list is empty, set both `head` and `tail` to the new node.\n    - Otherwise, set the `next` of the current `tail` to the new node, the `prev` of the new node to the current `tail`, and update the `tail` to be the new node.\n4.  **`addHead` Method:**\n    - Create a new node.\n    - If the list is empty, set both `head` and `tail` to the new node.\n    - Otherwise, set the `prev` of the current `head` to the new node, the `next` of the new node to the current `head`, and update the `head` to be the new node.\n5.  **`removeTail` Method:**\n    - If the list is not empty, store the value of the `tail`.\n    - If there's only one node, set `head` and `tail` to `null`.\n    - Otherwise, update the `tail` to be the previous node and set the new `tail`'s `next` to `null`.\n6.  **`removeHead` Method:**\n    - If the list is not empty, store the value of the `head`.\n    - If there's only one node, set `head` and `tail` to `null`.\n    - Otherwise, update the `head` to be the next node and set the new `head`'s `prev` to `null`.\n\nHints:\n\n- Always handle the edge case of an empty list.\n- When adding or removing nodes, be careful to update both the `next` and `prev` pointers correctly.\n- Keep track of the `length` of the list to provide a `size` method with O(1) time complexity.\n- The `find` method is useful for implementing the `delete` method.",
}

export default doublyLinkedListQuestion
