import type { Question } from "../../types"

const graphQuestion: Question = {
  category: "data-structures",
  level: "Medium",
  name: "Graph (Adjacency List)",
  solution:
    "export class Graph<T> {\n  private adjList: Map<T, T[]>\n\n  constructor() {\n    this.adjList = new Map()\n  }\n\n  public get nodes(): Map<T, T[]> {\n    return new Map(this.adjList)\n  }\n\n  public addVertex(vertex: T): void {\n    if (!this.adjList.has(vertex)) {\n      this.adjList.set(vertex, [])\n    }\n  }\n\n  public addEdge(vertex1: T, vertex2: T): void {\n    // Adds an undirected edge between two vertices.\n    // If vertices do not exist, they are added to the graph.\n    if (!this.adjList.has(vertex1)) {\n      this.addVertex(vertex1)\n    }\n    if (!this.adjList.has(vertex2)) {\n      this.addVertex(vertex2)\n    }\n    this.adjList.get(vertex1)?.push(vertex2)\n    this.adjList.get(vertex2)?.push(vertex1)\n  }\n\n  public removeVertex(vertex: T): void {\n    if (!this.adjList.has(vertex)) {\n      return\n    }\n    this.adjList.delete(vertex)\n    for (const adjacentVertices of this.adjList.values()) {\n      const index = adjacentVertices.indexOf(vertex)\n      if (index !== -1) {\n        adjacentVertices.splice(index, 1)\n      }\n    }\n  }\n\n  public removeEdge(vertex1: T, vertex2: T): void {\n    const v1Neighbors = this.adjList.get(vertex1)\n    const v2Neighbors = this.adjList.get(vertex2)\n    if (v1Neighbors && v2Neighbors) {\n      const index1 = v1Neighbors.indexOf(vertex2)\n      if (index1 !== -1) {\n        v1Neighbors.splice(index1, 1)\n      }\n      const index2 = v2Neighbors.indexOf(vertex1)\n      if (index2 !== -1) {\n        v2Neighbors.splice(index2, 1)\n      }\n    }\n  }\n\n  public bfs(startNode: T): T[] {\n    const visited = new Set<T>()\n    const queue: T[] = []\n    const result: T[] = []\n\n    if (!this.adjList.has(startNode)) {\n      return result\n    }\n\n    visited.add(startNode)\n    queue.push(startNode)\n\n    while (queue.length > 0) {\n      const currentNode = queue.shift()!\n      result.push(currentNode)\n\n      const neighbors = this.adjList.get(currentNode)!\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor)\n          queue.push(neighbor)\n        }\n      }\n    }\n    return result\n  }\n\n  public dfs(startNode: T): T[] {\n    const visited = new Set<T>()\n    const result: T[] = []\n\n    if (!this.adjList.has(startNode)) {\n      return result\n    }\n\n    const dfsRecursive = (currentNode: T) => {\n      visited.add(currentNode)\n      result.push(currentNode)\n\n      const neighbors = this.adjList.get(currentNode)!\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          dfsRecursive(neighbor)\n        }\n      }\n    }\n\n    dfsRecursive(startNode)\n    return result\n  }\n\n  public clear(): void {\n    this.adjList = new Map();\n  }\n}",
  synopsis:
    "Graph (Adjacency List)\n\nWhat is a Graph?\n\nA graph is a non-linear data structure consisting of a set of vertices (or nodes) and a set of edges that connect pairs of vertices. Graphs are used to model relationships between objects and are widely used in computer science for representing networks, such as social networks, transportation systems, and computer networks.\n\nHow it Works:\n\n- An adjacency list is a common way to represent a graph. It is a collection of unordered lists, one for each vertex in the graph. Each list describes the set of neighbors of its vertex.\n- In this implementation, we use a `Map` to store the adjacency list, where the keys are the vertices and the values are arrays of their adjacent vertices.\n- Adding a vertex involves adding a new key to the map with an empty array as its value.\n- Adding an edge between two vertices involves adding each vertex to the other's adjacency list.\n\nHow to Implement it:\n\n1.  **Graph Class:** Create a `Graph` class with a `adjList` property, which is a `Map`.\n2.  **`addVertex` Method:**\n    - Takes a vertex as input.\n    - If the vertex is not already in the `adjList`, add it as a key with an empty array as its value.\n3.  **`addEdge` Method:**\n    - Takes two vertices as input.\n    - For each vertex, if it's not in the `adjList`, add it.\n    - Add each vertex to the other's adjacency list.\n4.  **`removeVertex` Method:**\n    - Takes a vertex as input.\n    - If the vertex exists, remove it from the `adjList`.\n    - Iterate through the remaining vertices and remove the deleted vertex from their adjacency lists.\n5.  **`removeEdge` Method:**\n    - Takes two vertices as input.\n    - Remove each vertex from the other's adjacency list.\n6.  **`bfs` and `dfs` Methods:**\n    - Implement these traversal algorithms using a queue for BFS and recursion (or a stack) for DFS.\n\nHints:\n\n- The choice between an adjacency list and an adjacency matrix to represent a graph depends on the specific use case. Adjacency lists are generally more efficient for sparse graphs.\n- When implementing traversal algorithms, keep track of visited nodes to avoid infinite loops in graphs with cycles.\n- The `bfs` and `dfs` methods can be used to solve a variety of graph problems, such as finding connected components, shortest paths, and cycle detection.",
}

export default graphQuestion
