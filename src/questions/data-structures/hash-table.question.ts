import type { Question } from "../../types"

const hashTableQuestion: Question = {
  category: "data-structures",
  level: "Medium",
  name: "Hash Table",
  solution:
    "export class HashTable<K, V> {\n  private table: Array<\n    Array<\n      [\n        K,\n        V,\n      ]\n    >\n  >\n  private size: number\n\n  constructor(size: number = 127) {\n    this.table = new Array(size)\n    this.size = size\n  }\n\n  private hash(key: K): number {\n    // Converts the key to a string for hashing. \n    // Note: For complex objects, this might result in collisions \n    // (e.g., String({a: 1}) and String({b: 2}) both become '[object Object]').\n    // For better handling of object keys, a custom serialization or a different hashing strategy would be needed.\n    const keyStr = String(key)\n    let hash = 0\n    for (let i = 0; i < keyStr.length; i++) {\n      hash = (hash + keyStr.charCodeAt(i) * (i + 1)) % this.size\n    }\n    return hash\n  }\n\n  public set(key: K, value: V): void {\n    const index = this.hash(key)\n    if (!this.table[index]) {\n      this.table[index] = []\n    }\n\n    for (const pair of this.table[index]) {\n      if (pair[0] === key) {\n        pair[1] = value\n        return\n      }\n    }\n\n    this.table[index].push([\n      key,\n      value,\n    ])\n  }\n  public get(key: K): V | undefined {\n    const index = this.hash(key)\n    if (this.table[index]) {\n      for (const pair of this.table[index]) {\n        if (pair[0] === key) {\n          return pair[1]\n        }\n      }\n    }\n    return undefined\n  }\n\n  public delete(key: K): boolean {\n    const index = this.hash(key)\n    if (this.table[index]) {\n      for (let i = 0; i < this.table[index].length; i++) {\n        if (this.table[index][i]?.[0] === key) {\n          this.table[index].splice(i, 1)\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  public has(key: K): boolean {\n    return this.get(key) !== undefined\n  }\n\n  public clear(): void {\n    this.table = new Array(this.size);\n  }\n}",
  synopsis:
    "Hash Table\n\nWhat is a Hash Table?\n\nA hash table, also known as a hash map, is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index, also called a hash code, into an array of buckets or slots, from which the desired value can be found.\n\nHow it Works:\n\n- A hash table is an array of a fixed size. Each slot in the array is a bucket that can store one or more key-value pairs.\n- The `hash` function takes a key as input and returns an index into the array. A good hash function should distribute the keys as evenly as possible across the buckets to minimize collisions.\n- When a key-value pair is added, the hash function is used to determine the bucket where the pair should be stored. If the bucket is empty, the pair is added. If the bucket already contains one or more pairs (a collision), the new pair is added to the bucket using a collision resolution technique, such as chaining.\n- To retrieve a value, the hash function is used to find the bucket, and then the bucket is searched for the key.\n\nHow to Implement it:\n\n1.  **HashTable Class:** Create a `HashTable` class with a `table` property (an array) and a `size` property.\n2.  **`hash` Method:**\n    - Implement a hash function that takes a key and returns an index within the bounds of the table size.\n3.  **`set` Method:**\n    - Hash the key to get an index.\n    - If the bucket at the index is empty, create a new array (bucket).\n    - Check if the key already exists in the bucket. If so, update the value.\n    - Otherwise, add the new key-value pair to the bucket.\n4.  **`get` Method:**\n    - Hash the key to get an index.\n    - Search the bucket at the index for the key and return the corresponding value if found.\n5.  **`delete` Method:**\n    - Hash the key to get an index.\n    - Search the bucket at the index for the key and remove the key-value pair if found.\n\nHints:\n\n- The choice of hash function is crucial for the performance of a hash table. A good hash function should be fast to compute and should distribute the keys evenly.\n- Collision resolution is a key part of hash table implementation. Chaining (storing a linked list of key-value pairs in each bucket) is a common and effective technique.\n- The load factor of a hash table (the number of entries divided by the number of buckets) affects its performance. If the load factor becomes too high, the performance will degrade. In such cases, the table should be resized.",
}

export default hashTableQuestion
