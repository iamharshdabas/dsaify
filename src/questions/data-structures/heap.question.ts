import type { Question } from "../../types"

const heapQuestion: Question = {
  category: "data-structures",
  level: "Medium",
  solution:
    "/**\n * @class MinHeap\n * @description A binary heap data structure that maintains the min-heap property.\n */\nexport class MinHeap {\n  private heap: number[]\n\n  constructor() {\n    this.heap = []\n  }\n\n  /**\n   * @returns The number of elements in the heap.\n   */\n  public get size(): number {\n    return this.heap.length\n  }\n\n  /**\n   * @returns `true` if the heap is empty, `false` otherwise.\n   */\n  public isEmpty(): boolean {\n    return this.size === 0\n  }\n\n  /**\n   * @description Adds a new element to the heap.\n   * @param item The element to add.\n   */\n  public insert(item: number): void {\n    this.heap.push(item)\n    this.heapifyUp()\n  }\n\n  /**\n   * @description Removes and returns the minimum element from the heap.\n   * @returns The minimum element, or `null` if the heap is empty.\n   */\n  public extractMin(): number | null {\n    if (this.isEmpty()) {\n      return null\n    }\n    if (this.size === 1) {\n      const val = this.heap.pop()\n      return val === undefined ? null : val\n    }\n    const min = this.heap[0] as number // Assert as number, as heap is not empty\n    const lastElement = this.heap.pop()\n    if (lastElement !== undefined) {\n      this.heap[0] = lastElement\n    }\n    this.heapifyDown()\n    return min\n  }\n\n  /**\n   * @description Restores the min-heap property by moving the last element up.\n   */\n  private heapifyUp(): void {\n    let index = this.size - 1\n    while (this.hasParent(index) && (this.parent(index) as number) > this.heap[index]!) {\n      this.swap(this.getParentIndex(index), index)\n      index = this.getParentIndex(index)\n    }\n  }\n\n  /**\n   * @description Restores the min-heap property by moving the root element down.\n   */\n  private heapifyDown(): void {\n    let index = 0\n    while (this.hasLeftChild(index)) {\n      let smallerChildIndex = this.getLeftChildIndex(index)\n      if (this.hasRightChild(index) && (this.rightChild(index) as number) < (this.leftChild(index) as number)) {\n        smallerChildIndex = this.getRightChildIndex(index)\n      }\n\n      if (this.heap[index]! < this.heap[smallerChildIndex]!) {\n        break\n      }\n\n      this.swap(index, smallerChildIndex)\n      index = smallerChildIndex\n    }\n  }\n\n  private getParentIndex(childIndex: number): number {\n    return Math.floor((childIndex - 1) / 2)\n  }\n\n  private getLeftChildIndex(parentIndex: number): number {\n    return 2 * parentIndex + 1\n  }\n\n  private getRightChildIndex(parentIndex: number): number {\n    return 2 * parentIndex + 2\n  }\n\n  private hasParent(index: number): boolean {\n    return this.getParentIndex(index) >= 0\n  }\n\n  private hasLeftChild(index: number): boolean {\n    return this.getLeftChildIndex(index) < this.size\n  }\n\n  private hasRightChild(index: number): boolean {\n    return this.getRightChildIndex(index) < this.size\n  }\n\n  private parent(index: number): number | undefined {\n    return this.heap[this.getParentIndex(index)]\n  }\n\n  private leftChild(index: number): number | undefined {\n    return this.heap[this.getLeftChildIndex(index)]\n  }\n\n  private rightChild(index: number): number | undefined {\n    return this.heap[this.getRightChildIndex(index)]\n  }\n\n  private swap(i: number, j: number): void {\n    const temp = this.heap[i]!\n    this.heap[i] = this.heap[j]!\n    this.heap[j] = temp\n  }\n}",
  synopsis:
    "Min Heap\n\nWhat is a Heap?\n\nA heap is a specialized tree-based data structure that satisfies the heap property. In a min heap, for any given node C, if P is a parent node of C, then the value of P is less than or equal to the value of C. This means the smallest element is always at the root of the tree. Heaps are typically implemented as arrays, which saves the overhead of storing pointers to child nodes.\n\nHow it Works:\n\n- A heap is a complete binary tree, which means all levels of the tree are fully filled except possibly for the last level, which is filled from left to right.\n- The heap property is maintained through two primary operations: `heapifyUp` and `heapifyDown`.\n- `heapifyUp`: When a new element is added to the heap, it is placed at the end of the array. Then, it is repeatedly compared with its parent and swapped if it is smaller, until the heap property is restored.\n- `heapifyDown`: When the minimum element (the root) is removed, it is replaced by the last element in the heap. Then, this element is repeatedly compared with its children and swapped with the smaller child, until the heap property is restored.\n\nHow to Implement it:\n\n1.  **MinHeap Class:** Create a `MinHeap` class with a `heap` property, which is an array.\n2.  **Helper Methods:** Implement helper methods to get the indices of parent and child nodes, and to check for their existence.\n3.  **`insert` Method:**\n    - Add the new element to the end of the `heap` array.\n    - Call `heapifyUp` to restore the heap property.\n4.  **`extractMin` Method:**\n    - If the heap is empty, return `null`.\n    - Store the root element (the minimum).\n    - Replace the root with the last element in the heap.\n    - Call `heapifyDown` to restore the heap property.\n    - Return the stored minimum element.\n\nHints:\n\n- The array representation of a heap is very efficient. For a node at index `i`, its left child is at index `2i + 1`, its right child is at index `2i + 2`, and its parent is at index `floor((i - 1) / 2)`.\n- Heaps are the basis for the Heap Sort algorithm and are commonly used to implement priority queues.\n- A max heap is the opposite of a min heap, where the largest element is always at the root. The implementation is very similar, with the comparisons reversed.",
  title: "Min Heap",
}

export default heapQuestion
