import type { Question } from "../../types"

const linkedListQuestion: Question = {
  category: "data-structures",
  level: "Easy",
  solution:
    "/**\n * @class Node\n * @description Represents a node in the linked list.\n * @template T The type of the value stored in the node.\n */\nclass Node<T> {\n  public value: T\n  public next: Node<T> | null\n\n  constructor(value: T) {\n    this.value = value\n    this.next = null\n  }\n}\n\n/**\n * @class LinkedList\n * @description A linear data structure where each node points to the next node.\n * @template T The type of the values stored in the list.\n */\nexport class LinkedList<T> {\n  public head: Node<T> | null\n  private length: number\n\n  constructor() {\n    this.head = null\n    this.length = 0\n  }\n\n  /**\n   * @returns The number of nodes in the list.\n   */\n  public get size(): number {\n    return this.length\n  }\n\n  /**\n   * @returns `true` if the list is empty, `false` otherwise.\n   */\n  public isEmpty(): boolean {\n    return this.length === 0\n  }\n\n  /**\n   * @description Adds a new node with the given value to the end of the list.\n   * @param value The value to add.\n   */\n  public add(value: T): void {\n    const newNode = new Node(value)\n    if (this.isEmpty()) {\n      this.head = newNode\n    } else {\n      let current = this.head!\n      while (current.next) {\n        current = current.next\n      }\n      current.next = newNode\n    }\n    this.length++\n  }\n\n  /**\n   * @description Finds a node with the given value.\n   * @param value The value to find.\n   * @returns The node if found, `null` otherwise.\n   */\n  public find(value: T): Node<T> | null {\n    let current = this.head\n    while (current) {\n      if (current.value === value) {\n        return current\n      }\n      current = current.next\n    }\n    return null\n  }\n\n  /**\n   * @description Deletes a node with the given value.\n   * @param value The value to delete.\n   * @returns `true` if the node was deleted, `false` otherwise.\n   */\n  public delete(value: T): boolean {\n    if (!this.head) {\n      return false\n    }\n\n    if (this.head.value === value) {\n      this.head = this.head.next\n      this.length--\n      return true\n    }\n\n    let current = this.head\n    while (current.next && current.next.value !== value) {\n      current = current.next\n    }\n\n    if (current.next) {\n      current.next = current.next.next\n      this.length--\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * @description Converts the linked list to an array.\n   * @returns An array containing the values of the linked list.\n   */\n  public toArray(): T[] {\n    const result: T[] = []\n    let current = this.head\n    while (current) {\n      result.push(current.value)\n      current = current.next\n    }\n    return result\n  }\n}",
  synopsis:
    "Linked List\n\nWhat is a Linked List?\n\nA linked list is a linear data structure that consists of a sequence of nodes, where each node contains a value and a pointer to the next node in the sequence. Unlike arrays, linked lists do not store elements in contiguous memory locations. This allows for dynamic resizing and efficient insertion and deletion operations at the cost of slower access to elements.\n\nHow it Works:\n\n- Each node in a linked list is an object with two properties: `value` and `next`.\n- The list maintains a `head` pointer to the first node in the list.\n- To add a new node, you traverse the list until you reach the last node, and then set the `next` pointer of the last node to the new node.\n- To find a node, you traverse the list from the `head`, following the `next` pointers until you find the desired value or reach the end of the list.\n- To delete a node, you find the node to be deleted and update the `next` pointer of the previous node to point to the next node of the deleted node.\n\nHow to Implement it:\n\n1.  **Node Class:** Create a `Node` class with properties for `value` and `next`.\n2.  **LinkedList Class:** Create a `LinkedList` class with a `head` property and a `length` property.\n3.  **`add` Method:**\n    - Create a new node.\n    - If the list is empty, set the `head` to the new node.\n    - Otherwise, traverse to the end of the list and set the `next` of the last node to the new node.\n4.  **`find` Method:**\n    - Traverse the list from the `head`, comparing the `value` of each node with the target value.\n5.  **`delete` Method:**\n    - Handle the case where the node to be deleted is the `head`.\n    - Otherwise, find the node before the one to be deleted and update its `next` pointer.\n\nHints:\n\n- Keep track of the `length` of the list to provide a `size` method with O(1) time complexity.\n- Be careful to handle the edge case of an empty list.\n- The `find` method is a useful helper for the `delete` method.\n- For a more efficient implementation of adding to the tail, you can maintain a `tail` pointer in the `LinkedList` class.",
  title: "Linked List",
}

export default linkedListQuestion
