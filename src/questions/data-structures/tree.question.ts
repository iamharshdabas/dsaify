import type { Question } from "../../types"

const treeQuestion: Question = {
  category: "data-structures",
  level: "Medium",
  solution:
    "class TreeNode<T> {\n  value: T\n  left: TreeNode<T> | null\n  right: TreeNode<T> | null\n\n  constructor(value: T) {\n    this.value = value\n    this.left = null\n    this.right = null\n  }\n}\n\nexport class BinarySearchTree<T> {\n  root: TreeNode<T> | null\n\n  constructor() {\n    this.root = null\n  }\n\n  insert(value: T): void {\n    const newNode = new TreeNode(value)\n    if (!this.root) {\n      this.root = newNode\n      return\n    }\n\n    let current = this.root\n    while (true) {\n      if (value < current.value) {\n        if (!current.left) {\n          current.left = newNode\n          return\n        }\n        current = current.left\n      } else {\n        if (!current.right) {\n          current.right = newNode\n          return\n        }\n        current = current.right\n      }\n    }\n  }\n\n  find(value: T): boolean {\n    if (!this.root) {\n      return false\n    }\n\n    let current = this.root\n    while (current) {\n      if (value === current.value) {\n        return true\n      } else if (value < current.value) {\n        current = current.left!\n      } else {\n        current = current.right!\n      }\n      if (!current) break\n    }\n    return false\n  }\n\n  min(): T | null {\n    if (!this.root) {\n      return null\n    }\n    let current = this.root\n    while (current.left) {\n      current = current.left\n    }\n    return current.value\n  }\n\n  max(): T | null {\n    if (!this.root) {\n      return null\n    }\n    let current = this.root\n    while (current.right) {\n      current = current.right\n    }\n    return current.value\n  }\n\n  delete(value: T): void {\n    this.root = this._deleteNode(this.root, value)\n  }\n\n  private _deleteNode(node: TreeNode<T> | null, value: T): TreeNode<T> | null {\n    if (!node) {\n      return null\n    }\n\n    if (value < node.value) {\n      node.left = this._deleteNode(node.left, value)\n    } else if (value > node.value) {\n      node.right = this._deleteNode(node.right, value)\n    } else {\n      if (!node.left && !node.right) {\n        return null\n      } else if (!node.left) {\n        return node.right\n      } else if (!node.right) {\n        return node.left\n      } else {\n        let tempNode = node.right\n        while (tempNode.left) {\n          tempNode = tempNode.left\n        }\n        node.value = tempNode.value\n        node.right = this._deleteNode(node.right, tempNode.value)\n      }\n    }\n    return node\n  }\n\n  inOrderTraversal(callback: (value: T) => void): void {\n    this._inOrderTraversal(this.root, callback)\n  }\n\n  private _inOrderTraversal(node: TreeNode<T> | null, callback: (value: T) => void): void {\n    if (node) {\n      this._inOrderTraversal(node.left, callback)\n      callback(node.value)\n      this._inOrderTraversal(node.right, callback)\n    }\n  }\n\n  preOrderTraversal(callback: (value: T) => void): void {\n    this._preOrderTraversal(this.root, callback)\n  }\n\n  private _preOrderTraversal(node: TreeNode<T> | null, callback: (value: T) => void): void {\n    if (node) {\n      callback(node.value)\n      this._preOrderTraversal(node.left, callback)\n      this._preOrderTraversal(node.right, callback)\n    }\n  }\n\n  postOrderTraversal(callback: (value: T) => void): void {\n    this._postOrderTraversal(this.root, callback)\n  }\n\n  private _postOrderTraversal(node: TreeNode<T> | null, callback: (value: T) => void): void {\n    if (node) {\n      this._postOrderTraversal(node.left, callback)\n      this._postOrderTraversal(node.right, callback)\n      callback(node.value)\n    }\n  }\n}",
  synopsis:
    "Binary Search Tree (BST)\n\nWhat is a Binary Search Tree (BST)?\n\nA Binary Search Tree (BST) is a node-based binary tree data structure that has the following properties:\n\n1.  The left subtree of a node contains only nodes with values lesser than the node's value.\n2.  The right subtree of a node contains only nodes with values greater than the node's value.\n3.  The left and right subtrees must also be binary search trees.\n4.  There must be no duplicate nodes.\n\nThis ordering property allows for efficient searching, insertion, and deletion of elements.\n\nHow it Works:\n\nEach node in a BST typically contains:\n*   A `value` (or key).\n*   A `left` pointer to the left child node.\n*   A `right` pointer to the right child node.\n\nThe tree itself maintains a `root` pointer to the topmost node.\n\n*   **Insertion:** To insert a new value, you start at the root and traverse down the tree. If the new value is less than the current node's value, you go left; otherwise, you go right. You continue until you find an empty spot (a `null` child pointer), where you insert the new node.\n*   **Searching (Finding):** To find a value, you start at the root and compare the target value with the current node's value. If they match, you've found it. If the target is smaller, you go left; if larger, you go right. You continue until you find the value or reach a `null` pointer (meaning the value is not in the tree).\n*   **Deletion:** Deleting a node from a BST is more complex as it needs to maintain the BST properties. There are three cases:\n    *   **Node has no children:** Simply remove the node.\n    *   **Node has one child:** Replace the node with its child.\n    *   **Node has two children:** Find the in-order successor (smallest node in the right subtree) or in-order predecessor (largest node in the left subtree). Replace the node's value with the successor/predecessor's value, and then delete the successor/predecessor node (which will fall into one of the first two cases).\n*   **Traversal:** BSTs can be traversed in various ways:\n    *   **In-order Traversal:** Visits nodes in ascending order (Left -> Root -> Right).\n    *   **Pre-order Traversal:** Visits the root first, then left, then right (Root -> Left -> Right).\n    *   **Post-order Traversal:** Visits left, then right, then root (Left -> Right -> Root).\n\nHow to Implement it:\n\n1.  **`TreeNode` Class:** Define a `TreeNode` class with `value`, `left`, and `right` properties.\n2.  **`BinarySearchTree` Class:** Define a `BinarySearchTree` class with a `root` property.\n3.  **`insert(value)` Method:**\n    *   Create a new `TreeNode`.\n    *   If the tree is empty, set the new node as the `root`.\n    *   Otherwise, traverse the tree to find the correct insertion point, comparing `value` with current node's `value` to decide whether to go left or right.\n4.  **`find(value)` Method:**\n    *   Start at the `root`.\n    *   Traverse the tree, comparing `value` with current node's `value`.\n    *   Return `true` if found, `false` otherwise.\n5.  **`delete(value)` Method:**\n    *   Implement a recursive helper function `_deleteNode(node, value)` to handle the three deletion cases.\n    *   The main `delete` method will call this helper starting from the `root`.\n6.  **Traversal Methods (`inOrderTraversal`, `preOrderTraversal`, `postOrderTraversal`):**\n    *   Implement recursive helper functions for each traversal type.\n    *   These methods typically take a callback function to process each node's value.\n\nHints:\n\n*   **Recursion:** Many BST operations (especially deletion and traversals) are elegantly implemented using recursion.\n*   **Edge Cases:** Pay attention to edge cases like an empty tree, inserting the first node, deleting the root, or deleting a leaf node.\n*   **In-order Successor/Predecessor:** For deleting nodes with two children, correctly finding and handling the in-order successor (or predecessor) is crucial.\n*   **Type Constraints:** For a Binary Search Tree, the values stored must be comparable (e.g., numbers, strings). Ensure your type `T` supports comparison operations (`<`, `>`).\n*   **Applications:** BSTs are fundamental for implementing sets, maps, and are used in various algorithms requiring ordered data, such as sorting and searching.",
  title: "Binary Tree",
}

export default treeQuestion
