import type { Question } from "../../types"

const trieQuestion: Question = {
  category: "data-structures",
  level: "Hard",
  solution:
    "class TrieNode {\n  children: Map<string, TrieNode>\n  isEndOfWord: boolean\n\n  constructor() {\n    this.children = new Map()\n    this.isEndOfWord = false\n  }\n}\n\nexport class Trie {\n  root: TrieNode\n\n  constructor() {\n    this.root = new TrieNode()\n  }\n\n  insert(word: string): void {\n    let current = this.root\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        current.children.set(char, new TrieNode())\n      }\n      current = current.children.get(char)!\n    }\n    current.isEndOfWord = true\n  }\n\n  search(word: string): boolean {\n    let current = this.root\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        return false\n      }\n      current = current.children.get(char)!\n    }\n    return current.isEndOfWord\n  }\n\n  startsWith(prefix: string): boolean {\n    let current = this.root\n    for (const char of prefix) {\n      if (!current.children.has(char)) {\n        return false\n      }\n      current = current.children.get(char)!\n    }\n    return true\n  }\n\n  delete(word: string): boolean {\n    const deleteRecursive = (current: TrieNode, word: string, index: number): boolean => {\n      if (index === word.length) {\n        if (!current.isEndOfWord) {\n          return false // Word not found\n        }\n        current.isEndOfWord = false\n        return current.children.size === 0\n      }\n\n      const char = word[index]!\n      const child = current.children.get(char)\n\n      if (!child) {\n        return false // Word not found\n      }\n\n      const shouldDeleteChild = deleteRecursive(child, word, index + 1)\n\n      if (shouldDeleteChild) {\n        current.children.delete(char)\n        return current.children.size === 0 && !current.isEndOfWord\n      }\n\n      return false\n    }\n\n    return deleteRecursive(this.root, word, 0)\n  }\n}",
  synopsis:
    "Trie (Prefix Tree)\n\nWhat is a Trie?\n\nA Trie, also known as a prefix tree, is a tree-like data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the trie stores the key associated with that node; instead, its position in the tree defines the key. All the descendants of a node have a common prefix of the string associated with that node.\n\nTries are highly efficient for operations involving prefixes, such as searching for words with a common prefix, autocomplete suggestions, and spell checking.\n\nHow it Works:\n\nEach node in a trie typically represents a character in a string. The root node usually represents an empty string. Each path from the root to a node represents a prefix of a string. If a node marks the end of a valid word, it often has a flag (e.g., `isEndOfWord`) set to true.\n\n*   **Nodes:** Each node in a trie can have multiple children, typically one for each possible character in the alphabet (e.g., 26 for lowercase English letters). A `Map` or an array can be used to store these children.\n*   **Insertion (`insert`):** To insert a word, you traverse the trie character by character. If a character's path doesn't exist, you create a new node for it. Once all characters of the word have been processed, you mark the final node as the end of a word.\n*   **Search (`search`):** To search for a word, you traverse the trie character by character, following the path defined by the word. If at any point a character's path doesn't exist, the word is not in the trie. If you reach the end of the word and the final node is marked as `isEndOfWord`, the word exists.\n*   **Starts With (`startsWith`):** Similar to search, but you only need to check if the prefix path exists in the trie. You don't need to check the `isEndOfWord` flag.\n*   **Deletion (`delete`):** Deleting a word from a trie is more complex. It involves traversing the trie to find the word and unmarking its `isEndOfWord` flag. Then, you might need to remove nodes that are no longer part of any other word or prefix, backtracking up the tree.\n\nHow to Implement it:\n\n1.  **`TrieNode` Class:**\n    *   `children`: A `Map<string, TrieNode>` to store child nodes, where the key is the character and the value is the `TrieNode` for that character.\n    *   `isEndOfWord`: A boolean flag, `true` if this node marks the end of a complete word.\n\n2.  **`Trie` Class:**\n    *   `root`: A `TrieNode` representing the root of the trie.\n\n3.  **`insert(word)` Method:**\n    *   Start `current` at `this.root`.\n    *   For each `char` in `word`:\n        *   If `current.children` does not have `char`, create a new `TrieNode` and add it to `current.children` with `char` as the key.\n        *   Move `current` to `current.children.get(char)`.\n    *   Set `current.isEndOfWord = true`.\n\n4.  **`search(word)` Method:**\n    *   Start `current` at `this.root`.\n    *   For each `char` in `word`:\n        *   If `current.children` does not have `char`, return `false`.\n        *   Move `current` to `current.children.get(char)`.\n    *   Return `current.isEndOfWord`.\n\n5.  **`startsWith(prefix)` Method:**\n    *   Start `current` at `this.root`.\n    *   For each `char` in `prefix`:\n        *   If `current.children` does not have `char`, return `false`.\n        *   Move `current` to `current.children.get(char)`.\n    *   Return `true`.\n\n6.  **`delete(word)` Method (Recursive Approach):**\n    *   Implement a recursive helper function `deleteRecursive(current, word, index)`.\n    *   **Base Case:** If `index === word.length`:\n        *   If `current.isEndOfWord` is `false`, return `false` (word not found).\n        *   Set `current.isEndOfWord = false`.\n        *   Return `true` if `current.children.size === 0` (node can be deleted).\n    *   **Recursive Step:**\n        *   Get `char = word[index]` and `child = current.children.get(char)`.\n        *   If `child` is `null`, return `false` (word not found).\n        *   Call `shouldDeleteChild = deleteRecursive(child, word, index + 1)`.\n        *   If `shouldDeleteChild` is `true`:\n            *   Delete `char` from `current.children`.\n            *   Return `true` if `current.children.size === 0` AND `current.isEndOfWord` is `false`.\n    *   Return `false`.\n    *   The main `delete` method calls `deleteRecursive(this.root, word, 0)`.\n\nHints:\n\n*   **Space-Time Tradeoff:** Tries can consume a lot of memory, especially for large alphabets or long words, but they offer very fast search and insertion times (proportional to the length of the word, not the number of words).\n*   **Efficiency:** Operations like `insert`, `search`, and `startsWith` have a time complexity of O(L), where L is the length of the word/prefix, making them very efficient.\n*   **Applications:** Tries are commonly used in:\n    *   Autocomplete and predictive text systems.\n    *   Spell checkers.\n    *   IP routing (longest prefix matching).\n    *   Dictionary implementations.",
  title: "Trie (Prefix Tree)",
}

export default trieQuestion
